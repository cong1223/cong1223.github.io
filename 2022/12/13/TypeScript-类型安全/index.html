<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="小聪忙"><meta name="copyright" content="小聪忙"><meta name="generator" content="Hexo 5.3.0"><meta name="theme" content="hexo-theme-yun"><title>TypeScript 类型安全 | 聪忙的小站-Code &amp; Rock</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.22/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"cong1223.github.io","root":"/","title":"聪忙的小站","version":"1.4.0","mode":"auto","copycode":true,"page":{"isPost":true},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"algolia":{"appID":"FPFBIG0SN1","apiKey":"f75714621d5494f13edbe7a616932224","indexName":"hexo-blog","hits":{"per_page":8},"labels":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容: ${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="TypeScript 类型安全前言TypeScript 中有很多地方涉及到子类型 subtype、父类型 supertype、协变 Covariant 、逆变 Contravariant、双向协变 Bivariant 和不变 Invariant的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道它的缘由。 extends关键字在Type">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript 类型安全">
<meta property="og:url" content="https://cong1223.github.io/2022/12/13/TypeScript-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/index.html">
<meta property="og:site_name" content="聪忙的小站-Code &amp; Rock">
<meta property="og:description" content="TypeScript 类型安全前言TypeScript 中有很多地方涉及到子类型 subtype、父类型 supertype、协变 Covariant 、逆变 Contravariant、双向协变 Bivariant 和不变 Invariant的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道它的缘由。 extends关键字在Type">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-13T09:09:04.000Z">
<meta property="article:modified_time" content="2022-01-16T06:39:20.558Z">
<meta property="article:author" content="小聪忙">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="小聪忙"><img width="96" loading="lazy" src="/images/ghostwang.jpeg" alt="小聪忙"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">小聪忙</a></div><a class="site-name" href="/about/site.html">聪忙的小站-Code &amp; Rock</a><sub class="site-subtitle">记录分享前端领域技术博文</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">72</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">66</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://jq.qq.com/?_wv=1027&amp;k=g4dnBzs9" title="QQ 群 94500464" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/cong1223" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/5861177611" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=436106908" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/94308826" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131133736.png" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:1215524451@qq.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a><a class="links-item hty-icon-button" href="/girls/" title="喜欢的女孩子" style="color:hotpink"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-women-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.</span> <span class="toc-text">TypeScript 类型安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.0.2.</span> <span class="toc-text">extends关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.3.</span> <span class="toc-text">字面量类型匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#never"><span class="toc-number">1.0.4.</span> <span class="toc-text">never</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E5%80%BC%E5%8C%B9%E9%85%8D"><span class="toc-number">1.0.5.</span> <span class="toc-text">复杂类型值匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.6.</span> <span class="toc-text">父子类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%98%E8%B5%B7"><span class="toc-number">1.0.7.</span> <span class="toc-text">缘起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%8F%98%E5%8D%8F%E5%8F%98"><span class="toc-number">1.0.8.</span> <span class="toc-text">逆变协变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%EF%BC%88Covariance%EF%BC%89"><span class="toc-number">1.0.8.1.</span> <span class="toc-text">协变（Covariance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%8F%98%EF%BC%88Contravariance%EF%BC%89"><span class="toc-number">1.0.8.2.</span> <span class="toc-text">逆变（Contravariance）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%8D%8F%E5%8F%98"><span class="toc-number">1.0.9.</span> <span class="toc-text">双向协变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.10.</span> <span class="toc-text">函数属性与函数方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array"><span class="toc-number">1.0.11.</span> <span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">可变数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.11.2.</span> <span class="toc-text">更安全的数组类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.12.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.0.13.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://cong1223.github.io/2022/12/13/TypeScript-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="小聪忙"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="聪忙的小站-Code &amp; Rock"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">TypeScript 类型安全</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-12-13 17:09:04" itemprop="dateCreated datePublished" datetime="2022-12-13T17:09:04+08:00">2022-12-13</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-01-16 14:39:20" itemprop="dateModified" datetime="2022-01-16T14:39:20+08:00">2022-01-16</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">3.8k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">16m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/typescript/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">typescript</span></a></span></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="TypeScript-类型安全"><a href="#TypeScript-类型安全" class="headerlink" title="TypeScript 类型安全"></a>TypeScript 类型安全</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>TypeScript 中有很多地方涉及到子类型 <code>subtype</code>、父类型 <code>supertype</code>、协变 <code>Covariant</code> 、逆变 <code>Contravariant</code>、双向协变 <code>Bivariant</code> 和不变 <code>Invariant</code>的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道它的缘由。</p>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在TypeScript中，extends关键字在不同应用场景下有以下三种含义：</p>
<ol>
<li><strong>表示继承/拓展的含义:</strong></li>
</ol>
<p>继承父类的方法和属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> weight: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">public</span> age: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">wang</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;汪！&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">miao</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;喵~&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承类型</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  bark: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// Dog =&gt; &#123; age: number; bark(): void &#125;</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li><strong>表示约束的含义</strong></li>
</ol>
<p>在书写泛型的时候，我们往往需要对类型参数作一定的限制，比如希望传入的参数都有 name 属性的数组我们可以这么写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCnames</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; name: <span class="built_in">string</span> &#125;&gt;(entities: T[]):<span class="built_in">string</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> entities.map(<span class="function"><span class="params">entity</span> =&gt;</span> entity.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><strong>表示分配的含义（可赋值性 <code>assignable</code>）</strong></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Dog = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  bark: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bool = Dog <span class="keyword">extends</span> Animal ? <span class="string">&#x27;yes&#x27;</span> : <span class="string">&#x27;no&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>以下重点介绍表示分配含义，也就是可赋值性的一些用法</p>
<h3 id="字面量类型匹配"><a href="#字面量类型匹配" class="headerlink" title="字面量类型匹配"></a>字面量类型匹配</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Equal&lt;X, Y&gt; = X <span class="keyword">extends</span> Y ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Num = Equal&lt;<span class="number">1</span>, <span class="number">1</span>&gt;; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> Str = Equal&lt;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Boo1 = Equal&lt;<span class="literal">true</span>, <span class="literal">false</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> Boo2 = Equal&lt;<span class="literal">true</span>, <span class="built_in">boolean</span>&gt;; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>容易混淆：类型<code>X</code>可以分配给类型<code>Y</code>，而不是说类型<code>X</code>是类型<code>Y</code>的子集</strong></p>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>它自然被分配的一些例子：</p>
<ul>
<li>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) &#123;&#125;</code>）；</li>
<li>一个总是会抛出错误的函数（如：<code>function foo() &#123; throw new Error(&#39;Not Implemented&#39;) &#125;</code>，<code>foo</code> 的返回类型是 <code>never</code>）；</li>
</ul>
<p><strong>never是所有类型的子类型</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">never</span> <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">&#x27;x&#x27;</span> ? <span class="built_in">string</span> : <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> B = P&lt;<span class="built_in">never</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="复杂类型值匹配"><a href="#复杂类型值匹配" class="headerlink" title="复杂类型值匹配"></a>复杂类型值匹配</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> weight: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">public</span> age: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">wang</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;wang&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">miao</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;miao&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Equal&lt;X, Y&gt; = X <span class="keyword">extends</span> Y ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> Boo = Equal(Dog, Animal)</span><br><span class="line"><span class="keyword">type</span> Boo = Equal(Animal, Dog)</span><br></pre></td></tr></table></figure>


<p><code>type Boo = Equal(Animal, Dog) // false</code> 这是因为<code> Animal</code> 没有<code>bark</code>属性，类型<code>Animal</code>不满足类型<code>Dog</code>的类型约束。因此，<code>A extends B</code>，是指<strong>类型<code>A</code>可以<code>分配给</code>类型<code>B</code>，而不是说类型<code>A</code>是类型<code>B</code>的子集</strong>，理解<code>extends</code>在类型三元表达式里的用法非常重要。</p>
<h3 id="父子类型"><a href="#父子类型" class="headerlink" title="父子类型"></a>父子类型</h3><p>还是以动物类做比喻：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  bark: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal: Animal</span><br><span class="line"><span class="keyword">let</span> dog: Dog</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Animal</code> 是 <code>Dog</code> 的父类，<code>Dog</code>是<code>Animal</code>的子类型，子类型的属性比父类型更多，更具体。</p>
<ul>
<li>在类型系统中，属性更多的类型是子类型。</li>
<li>在集合论中，属性更少的集合是子集。</li>
</ul>
<p>也就是说，子类型是父类型的超集，而父类型是子类型的子集，这是直觉上容易搞混的一点。</p>
<p>记住一个特征，子类型比父类型更加<strong>具体</strong>，这点很关键。</p>
<p>上述例子中可以看出，<code>animal</code> 是一个「更宽泛」的类型，它的属性比较少，所以更「具体」的子类型是可以赋值给它的，因为你是知道 <code>animal</code> 上只有 <code>age</code> 这个属性的，你只会去使用这个属性，<code>dog</code> 上拥有 <code>animal</code> 所拥有的一切类型，赋值给 <code>animal</code> 是不会出现<strong>类型安全问题</strong>的。</p>
<p>反之，如果 <code>dog = animal</code>，那么后续使用者会期望 <code>dog</code> 上拥有 <code>bark</code> 属性，当他调用了 <code>dog.bark()</code> 就会引发运行时的崩溃。</p>
<p>从可赋值性角度来说，子类型是可以赋值给父类型的，也就是 <code>父类型变量 = 子类型变量</code> 是安全的，因为子类型上涵盖了父类型所拥有的的一切属性。</p>
<p>当我初学的时候，我会觉得 <code>T extends &#123;&#125;</code> 这样的语句很奇怪，为什么可以 <code>extends</code> 一个空类型并且在传递任意类型时都成立呢？当搞明白上面的知识点，这个问题也自然迎刃而解了。</p>
<p>到这里为止，算是基本讲完了extends的三种用法，以下进入正题：逆变协变、双向协变和不变</p>
<hr>
<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>ts写久了，有次在为某个组件写props类型的时候需要传一个onClick的时间函数类型时突然有个问题涌现脑海：</p>
<p>为什么在interface里面定义函数类型都是写成函数属性而不是方法，即:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  handleClick: <span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span>   <span class="comment">// 普遍写法</span></span><br><span class="line">  handleClick(arg: <span class="built_in">string</span>): <span class="built_in">number</span>  <span class="comment">// 非主流写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于在typescript-eslint中看到规则集时遇到了这个规则</p>
<p><a target="_blank" rel="noopener" href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md">@typescript-eslint/method-signature-style</a></p>
<p>规则案例如下：</p>
<p>❌ Incorrect</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">  func(arg: <span class="built_in">string</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T2 = &#123;</span><br><span class="line">  func(arg: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">interface</span> T3 &#123;</span><br><span class="line">  func(arg: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">  func(arg: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">  func(arg: <span class="built_in">boolean</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>✅ Correct</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">  func: <span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T2 = &#123;</span><br><span class="line">  func: <span class="function">(<span class="params">arg: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// this is equivalent to the overload</span></span><br><span class="line"><span class="keyword">interface</span> T3 &#123;</span><br><span class="line">  func: (<span class="function">(<span class="params">arg: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>) &amp;</span><br><span class="line">    (<span class="function">(<span class="params">arg: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>) &amp;</span><br><span class="line">    (<span class="function">(<span class="params">arg: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>A method and a function property of the same type behave differently. Methods are always bivariant in their argument, while function properties are contravariant in their argument under <code>strictFunctionTypes</code>.</p>
<p>相同类型的方法和函数属性的行为不同。方法在它们的参数中总是双变的，而函数属性在严格功能类型下的参数中是逆变的。</p>
</blockquote>
<p>看到这句话后也是一脸懵逼，第一次见到双向协变和逆变这两个词，于是查阅资料找到了他们的概念以及延伸的协变和不变</p>
<h3 id="逆变协变"><a href="#逆变协变" class="headerlink" title="逆变协变"></a>逆变协变</h3><p>先来段<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">维基百科的定义</a>：</p>
<blockquote>
<p>协变与逆变(covariance and contravariance)是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p>
</blockquote>
<p>咦，父/子型别关系前面好像也提到过，然后说起逆变和协变，又要提到前面说的可分配性，这也就是为什么文章开头要花大篇幅去介绍<code>extends</code>关键字的原因，在ts中决定类型之间的可分配性是基于结构化类型（<code>structural typing</code>）的</p>
<h4 id="协变（Covariance）"><a href="#协变（Covariance）" class="headerlink" title="协变（Covariance）"></a>协变（Covariance）</h4><p>那么想象一下，现在我们分别有这两个子类型的数组，他们之间的父子关系应该是怎么样的呢？没错，<code>Animal[]</code> 依然是 <code>Dog[]</code> 的父类型，对于这样的一段代码，把子类型赋值给父类型依然是安全的（兼容的）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  bark: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animals: Animal[]</span><br><span class="line"><span class="keyword">let</span> dogs: Dog[]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你用了一个更加具体的类型去接收原来的Animal类型了，此时你的类型是安全的，animal有的dog肯定有</span></span><br><span class="line">animals = dogs  <span class="comment">// 兼容,子（Dog）变父（Animal）（多变少）只要一个类型包含 age，我就可以认为它是一个和 Animal 兼容的类型。因此 dog 可以成功赋值给 animal，而对于多出来的 bark() 方法，可以忽略不计。</span></span><br><span class="line"></span><br><span class="line">dog = animal <span class="comment">// 不兼容</span></span><br></pre></td></tr></table></figure>
<p>转变成数组之后，对于父类型的变量，我们依然只会去找 <code>Dog</code> 类型中一定有的那些属性（因为子类型更加具体，父类型有的属性子类型都有）</p>
<p>那么，对于 <code>type MakeArray&lt;T&gt; = T[]</code> 这个类型构造器来说，它就是 <strong><code>协变（Covariance）</code></strong> 的。</p>
<h4 id="逆变（Contravariance）"><a href="#逆变（Contravariance）" class="headerlink" title="逆变（Contravariance）"></a>逆变（Contravariance）</h4><p>逆变确实比较难懂，先做一个有（无）趣（聊）的题（来源：《深入理解TypeScript》）</p>
<p>开始做题之前我们先约定如下的标记：</p>
<ul>
<li><code>A ≼ B</code> 意味着 <code>A</code> 是 <code>B</code> 的子类型。</li>
<li><code>A → B</code> 指的是以 <code>A</code> 为参数类型，以 <code>B</code> 为返回值类型的函数类型。</li>
<li><code>x : A</code> 意味着 <code>x</code> 的类型为 <code>A</code>。</li>
</ul>
<p><strong>问题</strong>：以下哪种类型是 <code>Dog → Dog</code> 的子类型呢？</p>
<ol>
<li><code>Greyhound → Greyhound</code></li>
<li><code>Greyhound → Animal</code></li>
<li><code>Animal → Animal</code></li>
<li><code>Animal → Greyhound</code></li>
</ol>
<p>让我们来思考一下如何解答这个问题。首先我们假设 <code>f</code> 是一个以 <code>Dog → Dog</code> 为参数的函数。它的返回值并不重要，为了具体描述问题，我们假设函数结构体是这样的： <code>f : (Dog → Dog) → String</code>。</p>
<p>现在我想给函数 <code>f</code> 传入某个函数 <code>g</code> 来调用。我们来瞧瞧当 <code>g</code> 为以上四种类型时，会发生什么情况。</p>
<p><strong>1. 我们假设 <code>g : Greyhound → Greyhound</code>， <code>f(g)</code> 的类型是否安全？</strong></p>
<p>不安全，因为在f内调用它的参数<code>(g)</code>函数时，使用的参数可能是一个不同于灰狗但又是狗的子类型，例如 <code>GermanShepherd</code> （牧羊犬）。</p>
<p><strong>2. 我们假设 <code>g : Greyhound → Animal</code>， <code>f(g)</code> 的类型是否安全？</strong></p>
<p>不安全。理由同(1)。</p>
<p><strong>3. 我们假设 <code>g : Animal → Animal</code>， <code>f(g)</code> 的类型是否安全？</strong></p>
<p>不安全。因为 <code>f</code> 有可能在调用完参数之后，让返回值，也就是 <code>Animal</code> （动物）狗叫。并非所有动物都会狗叫。</p>
<p><strong>4. 我们假设 <code>g : Animal → Greyhound</code>， <code>f(g)</code> 的类型是否安全？</strong></p>
<p>是的，它的类型是安全的。首先，<code>f</code> 可能会以任何狗的品种来作为参数调用，而所有的狗都是动物。其次，它可能会假设结果是一条狗，而所有的灰狗都是狗。</p>
<p>也就是说：在对类型分别调用如下的类型构造器之后：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MakeFunction&lt;T&gt; = <span class="function">(<span class="params">arg: T</span>) =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>
<p>父子类型关系逆转了(用上面的题来理解：Animal → Greyhound是Dog -&gt; Dog的子类型，但是Animal却是Dog的父类型)，这就是 **<code>逆变（Contravariance）</code>**。</p>
<p>通过 这个例子可以发现：</p>
<ul>
<li>返回值 -&gt; 协变（Greyhound -&gt; Dog）</li>
<li>入参通常应该为逆变（Animal &lt;- Dog）</li>
</ul>
<h3 id="双向协变"><a href="#双向协变" class="headerlink" title="双向协变"></a>双向协变</h3><p>TS鸭子类型系统，只要两个对象结构一致，就认为是同一种类型，而不需要两者的实际类型有显式的继承关系。</p>
<h3 id="函数属性与函数方法"><a href="#函数属性与函数方法" class="headerlink" title="函数属性与函数方法"></a>函数属性与函数方法</h3><p>了解了这两个概念之后我们可以大致猜测双向协变和不变的定义，双向协变那就是又可以协变又可以逆变，不变反之，既不能协变也不能逆变，现在我们先到之前困惑的地方：interface Props{}里面为什么建议用函数属性的写法定义函数类型？</p>
<p>用<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/18654">官方</a>的两个例子再次说明这个问题：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> f1: <span class="function">(<span class="params">x: Animal</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> f2: <span class="function">(<span class="params">x: Dog</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> f3: <span class="function">(<span class="params">x: Cat</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">f1 = f2;  <span class="comment">// Error with --strictFunctionTypes </span></span><br><span class="line">f2 = f1;  <span class="comment">// Ok</span></span><br><span class="line">f2 = f3;  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>第一个赋值在默认类型检查模式下是允许的，但在严格函数类型模式下被标记为错误。直觉上，默认模式允许赋值，因为它<em>可能是</em>合理的，而严格函数类型模式使它成为一个错误，因为它不能<em>证明是</em>合理的。在任何一种模式下，第三个赋值都是错误的，因为它<em>永远不会</em>是合理的。</p>
<p>描述示例的另一种方式是，类型在默认类型检查模式下<code>(x: T) =&gt; void</code>是<em>双</em>变的（即协变<em>或</em>逆变）<code>T</code>，但在严格函数类型模式下是<em>逆变</em>的<code>T</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Comparer&lt;T&gt; &#123;</span><br><span class="line">    compare(a: T, <span class="attr">b</span>: T): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> animalComparer: Comparer&lt;Animal&gt;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> dogComparer: Comparer&lt;Dog&gt;;</span><br><span class="line"></span><br><span class="line">animalComparer = dogComparer;  <span class="comment">// Ok because of bivariance</span></span><br><span class="line">dogComparer = animalComparer;  <span class="comment">// Ok (逆变)</span></span><br></pre></td></tr></table></figure>
<p>在<code>--strictFunctionTypes</code>mode 中，仍然允许第一个赋值，因为它<code>compare</code>被声明为一个方法。实际上，<code>T</code>是双变的，<code>Comparer&lt;T&gt;</code>因为它仅用于方法参数位置。但是，更改<code>compare</code>为具有函数类型的属性会导致更严格的检查生效：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Comparer&lt;T&gt; &#123;</span><br><span class="line">    compare: <span class="function">(<span class="params">a: T, b: T</span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> animalComparer: Comparer&lt;Animal&gt;;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">let</span> dogComparer: Comparer&lt;Dog&gt;;</span><br><span class="line"></span><br><span class="line">animalComparer = dogComparer;  <span class="comment">// Error</span></span><br><span class="line">dogComparer = animalComparer;  <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>
<p><strong>结论：在严格模式下（或者strictFunctionTypes）：类型安全问题将得到保障，与之相反的是默认双向协变将可能使得你在使用类型的时候变得不安全！</strong></p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>先抛出一个问题：<code>Array&lt;Dog&gt;</code> 能否为 <code>Array&lt;Animal&gt;</code> 的子类型？（来源：《深入理解TypeScript》）</p>
<p>先看下面这个例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  wang: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Cat <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  miao: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dogs: <span class="built_in">Array</span>&lt;Dog&gt; = []</span><br><span class="line"><span class="keyword">const</span> animals: Animal[] = dogs</span><br><span class="line"><span class="comment">// Array入参在ts中是双向协变的</span></span><br><span class="line">animals.push(<span class="keyword">new</span> Cat())</span><br></pre></td></tr></table></figure>
<p>如果列表是不可变的（immutable），那么答案是肯定的，因为类型很安全。但是假如列表是可变的，那么答案绝对是否定的！</p>
<h4 id="可变数据"><a href="#可变数据" class="headerlink" title="可变数据"></a>可变数据</h4><p>如果翻看typescript的Array的类型，可以看到Array类型定义写的是函数方法，因此，它的入参是双向协变的！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">    toString(): <span class="built_in">string</span>;</span><br><span class="line">    toLocaleString(): <span class="built_in">string</span>;</span><br><span class="line">    pop(): T | <span class="literal">undefined</span>;</span><br><span class="line">    push(...items: T[]): <span class="built_in">number</span>;</span><br><span class="line">    concat(...items: ConcatArray&lt;T&gt;[]): T[];</span><br><span class="line">    concat(...items: (T | ConcatArray&lt;T&gt;)[]): T[];</span><br><span class="line">    join(separator?: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">    reverse(): T[];</span><br><span class="line">    shift(): T | <span class="literal">undefined</span>;</span><br><span class="line">    slice(start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): T[];</span><br><span class="line">    sort(compareFn?: <span class="function">(<span class="params">a: T, b: T</span>) =&gt;</span> <span class="built_in">number</span>): <span class="built_in">this</span>;</span><br><span class="line">    splice(start: <span class="built_in">number</span>, deleteCount?: <span class="built_in">number</span>): T[];</span><br><span class="line">    splice(start: <span class="built_in">number</span>, <span class="attr">deleteCount</span>: <span class="built_in">number</span>, ...items: T[]): T[];</span><br><span class="line">    unshift(...items: T[]): <span class="built_in">number</span>;</span><br><span class="line">    indexOf(searchElement: T, fromIndex?: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    lastIndexOf(searchElement: T, fromIndex?: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    every(callbackfn: <span class="function">(<span class="params">value: T, index: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> <span class="built_in">boolean</span>, thisArg?: <span class="built_in">any</span>): <span class="built_in">boolean</span>;</span><br><span class="line">    some(callbackfn: <span class="function">(<span class="params">value: T, index: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> <span class="built_in">boolean</span>, thisArg?: <span class="built_in">any</span>): <span class="built_in">boolean</span>;</span><br><span class="line">    forEach(callbackfn: <span class="function">(<span class="params">value: T, index: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> <span class="built_in">void</span>, thisArg?: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">    map&lt;U&gt;(callbackfn: <span class="function">(<span class="params">value: T, index: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> U, thisArg?: <span class="built_in">any</span>): U[];</span><br><span class="line">    filter&lt;S <span class="keyword">extends</span> T&gt;(callbackfn: <span class="function">(<span class="params">value: T, index: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> value is S, thisArg?: <span class="built_in">any</span>): S[];</span><br><span class="line">    filter(callbackfn: <span class="function">(<span class="params">value: T, index: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> <span class="built_in">any</span>, thisArg?: <span class="built_in">any</span>): T[];</span><br><span class="line">    reduce(callbackfn: <span class="function">(<span class="params">previousValue: T, currentValue: T, currentIndex: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> T): T;</span><br><span class="line">    reduce(callbackfn: <span class="function">(<span class="params">previousValue: T, currentValue: T, currentIndex: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> T, <span class="attr">initialValue</span>: T): T;</span><br><span class="line">    reduce&lt;U&gt;(callbackfn: <span class="function">(<span class="params">previousValue: U, currentValue: T, currentIndex: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> U, <span class="attr">initialValue</span>: U): U;</span><br><span class="line">    reduceRight(callbackfn: <span class="function">(<span class="params">previousValue: T, currentValue: T, currentIndex: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> T): T;</span><br><span class="line">    reduceRight(callbackfn: <span class="function">(<span class="params">previousValue: T, currentValue: T, currentIndex: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> T, <span class="attr">initialValue</span>: T): T;</span><br><span class="line">    reduceRight&lt;U&gt;(callbackfn: <span class="function">(<span class="params">previousValue: U, currentValue: T, currentIndex: <span class="built_in">number</span>, array: T[]</span>) =&gt;</span> U, <span class="attr">initialValue</span>: U): U;</span><br><span class="line">    [n: <span class="built_in">number</span>]: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可变数组+双向协变无法保证类型安全</strong></p>
<h4 id="更安全的数组类型"><a href="#更安全的数组类型" class="headerlink" title="更安全的数组类型"></a>更安全的数组类型</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MutableArray&lt;T&gt; &#123;</span><br><span class="line">		length: <span class="built_in">number</span>;</span><br><span class="line">    toString: <span class="built_in">string</span>;</span><br><span class="line">    toLocaleString(): <span class="built_in">string</span>;</span><br><span class="line">    pop: <span class="function">() =&gt;</span> T | <span class="literal">undefined</span>;</span><br><span class="line">    push: <span class="function">(<span class="params">...items: T[]</span>) =&gt;</span>  <span class="built_in">number</span>;</span><br><span class="line">    concat:<span class="function">(<span class="params">...items: ConcatArray&lt;T&gt;[]</span>) =&gt;</span> T[];</span><br><span class="line">    join: <span class="function">(<span class="params">separator?: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line">    reverse: <span class="function">() =&gt;</span> T[];</span><br><span class="line">    shift:<span class="function">() =&gt;</span> T | <span class="literal">undefined</span>;</span><br><span class="line">    slice:<span class="function">(<span class="params">start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span></span>) =&gt;</span> T[];</span><br><span class="line">    sort:<span class="function">(<span class="params">compareFn?: (a: T, b: T) =&gt; <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">    indexOf: <span class="function">(<span class="params">searchElement: T, fromIndex?: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（思考：为什么）此时我们会发现MutableArray其实是个不可变类型，不再能互相分配</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dogs: MutableArray&lt;Dog&gt; = [] <span class="keyword">as</span> Dog[];</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> animals: MutableArray&lt;Animal&gt; = dogs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animals: MutableArray&lt;Animal&gt; = [] <span class="keyword">as</span> Animal[] ;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">const</span> dogs: MutableArray&lt;Dog&gt; = animals</span><br></pre></td></tr></table></figure>
<p>原因是Array类型既存在逆变方法push也存在协变方法pop（满足相互分配的条件？假设满足，那么MutableArray<Dog>和MutableArray<Animal>里面的pop跟push方法如果做兼容？需要同时满足参数逆变和返回值协变才能兼容）</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>可以使用readonly来标记属性，使其不可变</li>
<li>更多地使用函数属性而不是函数方法来定义类型</li>
<li>尝试让类型中的协变或者逆变分开，或者让类型不可变</li>
<li>尽可能避免双向协变</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]@typescript-eslint/method-signature-style: <em><a target="_blank" rel="noopener" href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md">https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md</a></em></p>
<p>[2]PR: <em><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/18654">https://github.com/microsoft/TypeScript/pull/18654</a></em></p>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131143747.jpeg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131143747.jpeg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131143944.jpeg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131143944.jpeg" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131143746.jpeg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cong1223/cloudimg@master/img/20210131143746.jpeg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>小聪忙</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://cong1223.github.io/2022/12/13/TypeScript-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/" title="TypeScript 类型安全">https://cong1223.github.io/2022/12/13/TypeScript-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/01/16/%E7%94%A8js%E7%8E%A9%E8%BD%ACScriptable%EF%BC%8C%E8%B6%85%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/" rel="next" title="用js玩转Scriptable，超简单教程"><span class="post-nav-text">用js玩转Scriptable，超简单教程</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/cong1223/cong1223.github.io/issues?q=is:issue+TypeScript 类型安全">GitHub Issues</a><a class="hty-button hty-button--raised" id="github-discussions" target="_blank" rel="noopener" href="https://github.com/cong1223/cong1223.github.io/discussions/new">GitHub Discussions</a></div><div id="disqus_thread"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@latest/dist/disqusjs.css"><script src="https://cdn.jsdelivr.net/npm/disqusjs@latest/dist/disqus.js"></script><script>const disqusjsConfig = {"enable":true,"shortname":"ghostwang-com"}
function loadDisqus() {
  const dsqjs = new DisqusJS(disqusjsConfig)
}</script><script src="/js/comments/disqus.js"></script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备17038157号</a></div><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 小聪忙</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></div></body></html>